---
title: "`BayesMallows`: An R Package for Probabilistic Preference Learning with the Mallows Rank Model"
author: "Øystein Sørensen"
date: "`r Sys.Date()`"
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BayesMallows Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(232312)
```

The `BayesMallows` package implements methods for Bayesian preference learning with the Mallows rank model, as originally described in @vitelli2018, and further developed in @asfaw2016 and @crispino2018. This vignette describes the usage of the package, starting from the complete data cases, through top-$k$ rankings, pairwise comparisons, and finally clustering. We refer to the above mentioned papers, as well as the review @liu2018 for a thorough description of the methods. The necessary methods for data preprocessing, tuning of algorithms, and assessment of the posterior distributions will be described along the way. For ways to compute the partition function of the Mallows rank model with various distance measures, please see the separate vignette.



## Mixture of Mallows Models



```{r, message=FALSE}
library(BayesMallows)
```

We also need some packages for plotting and data wrangling.
```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
```


# Overview of Package

## Functions

Here is an overview of the most used function. You can read their documentation with `?function_name`, or search for an example in this vignette.

----------------------------- ------------------------------------------------------
Function Name                 Description
----------------------------- ------------------------------------------------------
`compute_mallows`             Compute the posterior distribution of the Bayesian Mallows model. This is the main function of the package. Returns an object of class `BayesMallows`.

`compute_mallows_mixtures`    Compute multiple Mallows models with different number of mixture components. This is a convenience function for determining the number of mixtures to use.

`sample_mallows`              Sample from the Mallows model.

`plot.BayesMallows`           Quick plots of the posterior densities of $\alpha$ and $\rho$.

 `assess_convergence`         Study the convergence of the Markov chain, in order to determine burnin and other algorithm parameters.  
 
 `plot_elbow`                 Create an elbow plot for comparing models with different number of clusters. 
 
 `plot_top_k`                 Plot the top-$k$ rankings. Particularly relevant when the data is in the form of pairwise comparisons. 
 
 `assign_cluster`             Compute the cluster assignment of assessors.
 
 `compute_map_consensus`       Compute the MAP estimate of the latent ranks. 
 
 `compute_cp_consensus`       Rank the items according to their CP consensus. 
 
 `compute_posterior_intervals` Compute Bayesian posterior intervals for the parameters. 
 
 `generate_initial_ranking`    Generate an initial ranking, for the case of missing data or pairwise comparisons. 
 
 `generate_transitive_closure` Generate the transitive closure for a set of pairwise comparisons. 
 
 `estimate_partition_function` Estimate the partition function of the Mallows model using either importance sampling or an asymptotic approximation.
------------------- --------------------------------------------------

: Main functions in the `BayesMallows` package.

## Datasets

Here is an overview of the example datasets in `BayesMallows`. You can read their documentation with `?dataset_name`, or search for an example in this vignette.

----------------------------- ------------------------------------------------------
Dataset Name                  Description
----------------------------- ------------------------------------------------------
`beach_preferences`           Stated pairwise preferences between random subsets of 15 images of beaches, by 60 assessors.

`sushi_rankings`              Complete rankings of 10 types of sushi by 5000 assessors.

`potato_visual`               Complete rankings of 20 potatoes by weight, based on visual inspection, by 12 assessors.

`potato_weighing`             Complete rankings of 20 potatoes by weight, where the assessors were allowed to weigh the potatoes in their hands, by 12 assessors.

`potato_true_ranking`         Vector of true weight rankings for the 20 potatoes in the example datasets `potato_visual` and `potato_weighing`.
------------------- --------------------------------------------------

: Example datasets in the `BayesMallows` package.


# Mallows' Rank Model
We here give an informal review of the Mallows model (@mallows1957). The distribution of a ranking $r \in \mathcal{P}_{n}$ of $n$ items is modeled as

$$ P(r | \alpha, \rho) = Z_{n}(\alpha)^{-1} \exp\left\{-\frac{\alpha}{n} d(r, \rho)\right\} 1_{\mathcal{P}_{n}}(r), $$

where $\mathcal{P}_{n}$ is the set of all permutations of $1, \dots, n$, $\alpha$ is a scale parameter, $\rho \in \mathcal{P}_{n}$ is a latent consensus ranking, $d(\cdot, \cdot)$ is a distance measure, $1_{S}(\cdot)$ is the indicator function for the set $S$, and $Z_{n}(\alpha)$ is the partition function, or normalizing constant.

Given $N$ observed rankings, $R_{1}, \dots, R_{N}$, the likelihood of the model is

$$ P(R_{1}, \dots, R_{N} | \alpha, \rho) = Z_{n}(\alpha)^{-N} \exp\left\{-\frac{\alpha}{n} \sum_{j=1}^{N}d(R_{j}, \rho)\right\} \prod_{j=1}^{N} \left\{1_{\mathcal{P}_{n}}(R_{j}) \right\}. $$

The `rankings` argument to `compute_mallows` is assumed to be a matrix of the form $(R_{1}, R_{2}, \dots, R_{N})^{T}$, i.e., each row contains a ranking and each column is an item.

## Prior Distributions
For $\alpha$ we use an exponential prior, with density $\pi(\alpha | \lambda) =  \lambda \exp(-\lambda \alpha).$ The rate parameter $\lambda$ can be set by the user with the `lambda` argument to `compute_mallows`. For $\rho$ we assume a uniform prior distribution on $\mathcal{P}_{n}$, with density $\pi(\rho) = 1_{\mathcal{P}_{n}}(\rho) /n!.$

## Metropolis-Hastings Algorithm
We use a Metropolis-Hastings algorithm for computing the posterior distributions of $\alpha$ and $\rho$. We propose $\alpha$ from a lognormal distribution $\log \mathcal{N}(\log(\alpha), \sigma_{\alpha}^{2})$. We propose $\rho$ with a leap-and-shift algorithm, described in detail in @vitelli2018. The standard deviation $\sigma_{\alpha}^{2}$ and the leap size can be set by the user with the arguments `alpha_prop_sd` and `leap_size` to `compute_mallows`.

## Partial Rankings
If each assessor $j$ has ranked a subset of the items $\mathcal{A}_{j}$, we use data augmentation to fill in the missing ranks. We define the augmented data vectors $\tilde{R}_{1}, \dots, \tilde{R}_{N}$, and use a uniform prior for each assessor with support $\mathcal(P)_{n} \setminus R_{j}$, i.e., the set of rankings not already chosen. The Metropolis-Hastings algorithm now alternates between sampling $\tilde{R}_{1}, \dots, \tilde{R}_{N}$ given the current $\alpha$ and $\rho$, and sampling $\alpha$ and $\rho$ given the current $\tilde{R}_{1}, \dots, \tilde{R}_{N}$.

## Pairwise Comparisons
When the assessors have stated a set of pairwise comparisons, rather than rankings, we use the same data augmentation ideas as for partial rankings, but the proposal distribution is slightly more complicated in order to ensure that the proposed ranking is compliant with the ordering implied by the pairwise comparisons. In addition, the transitive closure of the stated ordering has to be computed, in order to find all *implied orderings*. From a user perspective, no new algorithm parameters need to be considered.

## Mixtures of Mallows Models
When the assessor pool is heterogeneous, one might assume that there exist several latent consensus rankings, $\rho_{1}, \dots, \rho_{C}$, one for each cluster of assessors. Letting $z_{1}, \dots, z_{N} \in\{1, \dots, C\}$ assign each assessor to each cluster, the likelihood of the observed rankings is 

$$P(R_{1}, \dots, R_{N} | \{\alpha_{c}, \rho_{c}\}_{c=1,\dots,C}, z_{1},\dots,z_{N}) = \prod_{j=1}^{N}\frac{1_{\mathcal{P}_{n}}(\rho)}{Z_{n}(\alpha_{z_{j}})}\exp\left\{ -\frac{\alpha_{z_{j}}}{n} d(R_{j}, \rho_{z_{j}})\right\}. $$
For the scale parameters $\alpha_{1}, \dots, \alpha_{C}$ we assume the exponential prior as before, all with the same rate parameter $\lambda$. We assume that the cluster labels are a priori distributed according to $P(z_{1}, \dots, z_{N} | \tau_{1}, \dots, \tau_{C}) = \prod_{j=1}^{N} \tau_{z_{j}}$, where $\tau_{c}$ is the a priori probability that an assessor belongs to cluster $c$. For $\tau_{1}, \dots, \tau_{C}$ we assume the Dirichlet prior $\pi(1, \dots, C) = \Gamma(\psi C)\Gamma(\psi)^{-C}\prod_{c=1}^{C}\tau_{c}^{\psi - 1}$, where $\Gamma(\cdot)$ is the gamma function. The user can control the value of $\psi$ with the `psi` argument to `compute_mallows`.

# BayesMallows User Guide

Having described the model, we now show some case studies demonstrating the use of the `BayesMallows` package. To reduce the computing time, we have typically taken a fairly small number of posterior samples, and rather focused on demonstrating the different methods. In general, we recommend taking a larger number of samples than what we do here, in order to obtain good approximations of the posterior distributions.

## Completely Ranked Data
`BayesMallows` comes with example data described in @liu2018. A total of 12 assessors were asked to rank 20 potatoes based on their weight. In the first round, the assessors were only allowed to study the potatoes visually, while in the second round, the assessors were also allowed to hold the potatoes in their hands in order to compare them. The data sets are named `potato_visual` and `potato_weighing`, respectively. The true ordering of the potatoes' weights are stored in the vector `potato_true_ranking`.

The `potato_visual` dataset is shown below. The column names P1, ..., P20 represent potatoes, and the row names A1, ..., A12 represent assessors. The `potato_weighing` dataset has a similar structure.

```{r, echo=FALSE, results='asis'}
knitr::kable(potato_visual, caption = "Example dataset `potato_visual`.")
```

### Algorithm Tuning

The `compute_mallows` function is the workhorse of `BayesMallows`. It runs the Metropolis-Hastings algorithm and returns the posterior distribution of the scale parameter $\alpha$ and the latent ranks $\rho$ of the Mallows model. To see all its arguments, please run `?compute_mallows` in the console.

We start by using all the default values of the parameters, so we only need to supply the matrix of ranked items. We use the `potato_visual` data printed above. 

```{r}
model_fit <- compute_mallows(potato_visual)
```

The argument returned is a list object of class `BayesMallows`, which contains a whole lot of information about the MCMC run.

```{r, eval=FALSE}
class(model_fit)
names(model_fit)
```

The function `assess_convergence` produces plots for visual convergence assessment. We start by studying $\alpha$, which is the default. The plot is shown below, and looks good enough, at least to begin with.

```{r, fig.width=6}
assess_convergence(model_fit)
```

Next, we study the convergence of $\rho$. To avoid too complicated plots, we pick 5 items to plot. Again, you can read more about this function by running `?assess_convergence` in the console.

```{r, fig.width=6}
assess_convergence(model_fit, type = "rho", items = 1:5)
```

Based on these plots, it looks like the algorithm starts to converge after around 1000 iterations. Discarding the first 1000 iterations as burn-in hence seems like a safe choice. We create a new list element for `model_fit` called `burnin`, in which this choice is saved. Having done this, we do not have to provide a `burnin` argument to subsequent analyses of the posterior distributions.

```{r}
model_fit$burnin <- 1000
```


### Posterior Distributions

Once we are confident that the algorithm parameters are reasonable, we can study the posterior distributions of the model parameters using the generic function `plot.BayesMallows`.

#### Scale Parameter $\alpha$

With a burnin of 1000, the original `model_fit` object from the previous subsection has 1000 MCMC samples. The default parameter of `plot.BayesMallows` is $alpha$, so we can study the posterior distribution with the simple statement below.

```{r}
plot(model_fit)
```


We can also get the posterior credible intervals for $\alpha$:

```{r}
intervals <- compute_posterior_intervals(model_fit, parameter = "alpha")
```

```{r, echo=FALSE, results='asis'}
knitr::kable(intervals)
```

#### Latent Ranks $\rho$
Obtaining posterior samples from $\rho$ is in general harder than for $\alpha$. Some items tend to be very sticky. We start by plotting the `model_fit` object from above. We now have to tell `plot.BayesMallows` that we want a plot of `type = "rho"` and all the items. This gives us posterior the posterior density of all the items.

```{r, fig.width=6, fig.height=6}
plot(model_fit, type = "rho", items = 1:20)
```


We can also find the posterior intervals of the latent ranks:

```{r, eval=FALSE}
compute_posterior_intervals(model_fit, parameter = "rho")
```


```{r, echo=FALSE, results='asis'}
knitr::kable(compute_posterior_intervals(model_fit, parameter = "rho"))
```



#### Jumping over $\alpha$
Updating $\alpha$ in each step may not be necessary. With the `alpha_jump` argument, we can tell the MCMC algorithm to update $\alpha$ only every `alpha_jump`th iteration.

```{r}
model_fit <- compute_mallows(potato_visual, alpha_jump = 10)
```

We should assess convergence again:

```{r, fig.width=6}
assess_convergence(model_fit, type = "alpha")
```



#### Thinning

Saving a large number of iterations of $\rho$ gets quite expensive, so `compute_mallows` has a `rho_thinning` parameter. It specifies that only each `rho_thinning`th iteration of $\rho$ should be saved to memory. We double the number of iterations, while setting `rho_thinning = 2`. This gives us the same number of posterior samples.

Please be careful with thinning. In this small data example it is definitely wasteful! Running the same number of iterations without thinning always gives a better approximation of the posterior distribution. Thinning might be useful when you need to run a large number of iterations to explore the space of latent ranks, and the latent ranks from all iterations do not fit in memory. (See, e.g., @gelman2004 for a discussion of thinning).

```{r, eval=FALSE}
model_fit <- compute_mallows(potato_visual, alpha_jump = 10, rho_thinning = 2)
```


### Varying the Distance Metric

We can try to use the Kendall distance instead of the footrule distance.

```{r, eval=FALSE}
model_fit <- compute_mallows(potato_visual, metric = "kendall")
```



### Validation of Input

It is also worth pointing out that `compute_mallows` checks if the input data are indeed ranks. Let us try this by manipulating the first row of `potato_visual`, giving rank 1 to the first two items:

```{r, error=TRUE}
potato_modified <- potato_visual
potato_modified[1, 1:2] <- 1

model_fit <- compute_mallows(potato_modified)
```


## Top-$k$ Rankings

### Encoding of Missing Ranks
Now imagine that the assessors in the potato experiment were asked to rank only the top-five heaviest potatoes. We generate these data by retaining only ranks 5 or higher in `potato_visual`, setting the rest to `NA`.

```{r, message=FALSE}
potato_top <- potato_visual * if_else(potato_visual > 5, NA_integer_, 1L)
```

In @vitelli2018 it is shown that the unranked items do not effect the MAP estimates of the ranked items in this top-k setting. In this case, there are 8 potatoes which have been ranked, and so the unranked potatoes should have uniform posterior distributions between 9 and 20. However, arriving at these uniform posteriors require a large number of MCMC iterations, so we instead remove these items:

```{r}
item_ranked <- apply(potato_top, 2, function(x) !all(is.na(x)))
potato_top <- potato_top[, item_ranked, drop = FALSE]
```

We are now left with this 12 by 8 matrix:

```{r, echo=FALSE, results='asis'}
knitr::kable(potato_top, caption = "Example dataset `potato_top`.")
```

### Metropolis-Hastings Algorithm with Missing Ranks

The `compute_mallows` function automatically recognizes the `NA` values as missing ranks, and augments the data, as described in Section 4.1 of @vitelli2018. Let us try:

```{r}
model_fit <- compute_mallows(potato_top, save_augmented_data = TRUE)
```

Looking at the returned object, we see that `any_missing` is `TRUE`, so `compute_mallows` has correctly detected that there are missing values. We set `save_augmented_data = TRUE` so we can get a diagnostic plot for the convergence of the data augmentation. After you are confident that the algorithm converges, you might want to use the default `save_augmented_data = FALSE`, because saving the data takes memory.

```{r}
model_fit$any_missing
```

`model_fit` also has assessor-wise acceptance rates for the augmentation.

```{r, eval=FALSE}
model_fit$aug_acceptance
```


```{r, echo=FALSE, result='asis'}
knitr::kable(model_fit$aug_acceptance, digits = 2)
```


### Algorithm Tuning

The tuning of $\alpha$ and $\rho$ can be done exactly as described above for the full potato data. Let us now study the convergence of the data augmentation.

Looking back, we see that assessor 1 does not have values for potatoes 14, 16, and 17. Hence, we expect these to jump between ranks 6, 7, and 8, since the 5 ranked items are fixed to values 1,...,5. Below we have plotted potato 14, which fluctuates between 6 and 8. You can confirm that these same happens to 16 and 17.

```{r, fig.width=6}
assess_convergence(model_fit, type = "Rtilde", assessors = 1, 
                   items = "P14")
```

Assessor 1 has ranks for potatoes 7, 9, 10, 12, and 13, which are fixed. You can confirm that they are fixed by running the following command.

```{r, eval=FALSE}
assess_convergence(model_fit, type = "Rtilde", assessors = 1, 
                   items = c("P7", "P9", "P10", "P12", "P13"))
```

### Posterior Distributions

We can study the posterior distributions of $\alpha$ and $\rho$ just like we did above.

### Other Distance Measures

Like for the complete ranks, we can vary the distance measure used in the Mallows model. Here are command for running with Cayley, Kendall, and Spearman distance.

```{r, eval=FALSE}
model_fit <- compute_mallows(potato_top, metric = "cayley")
model_fit <- compute_mallows(potato_top, metric = "kendall")
model_fit <- compute_mallows(potato_top, metric = "spearman")
```


## Ranks Missing at Random

If the ranks are missing at random, we cannot remove the unranked items as we did for top-$k$ rankings above. Let us assume that 10 % of the data in `potato_visual` have disappeared due to a disk failure. We generate these in the code chunk below:

```{r}
missing_indicator <- if_else(
  runif(nrow(potato_visual) * ncol(potato_visual)) < 0.1,
                            NA_real_, 1)
potato_missing <- potato_visual * missing_indicator
```

The data now look like the following:

```{r, echo=FALSE, results='asis'}
knitr::kable(potato_missing, caption = "Example dataset `potato_missing`.")
```

### Algorithm Tuning
We supply `potato_missing` to `compute_mallows` as before:

```{r}
model_fit <- compute_mallows(potato_missing)
```

We check the convergence with the following commands. The plots (not shown) would show good convergence before 1,000 iterations.

```{r, eval=FALSE}
assess_convergence(model_fit)
```

```{r, eval=FALSE}
assess_convergence(model_fit, type = "rho", items = 1:6)
```

Again, we can look at the acceptance rates for the augmented data. Now let us compare it to the number of missing ranks per assessor.

```{r, eval=FALSE}
bind_cols(model_fit$aug_acceptance, 
          n_missing = apply(potato_missing, 1, function(x) sum(is.na(x))))
```


```{r, echo=FALSE, result='asis'}
knitr::kable(
  bind_cols(model_fit$aug_acceptance, 
          n_missing = apply(potato_missing, 1, function(x) sum(is.na(x)))), 
  digits = 2)
```

We see that for assessors who have either 0 or 1 missing ranks, their augmentations are always accepted. In the case of 0 missing ranks, there is in fact no augmentation going on at all, but we use the convention that the assessor's own complete data is accepted.

### Posterior Distributions

The posterior distributions can be studied as shown above.

## Pairwise Preferences

Handling of pairwise preferences in the Mallows rank model is described in Section 4.2 of @vitelli2018.

### Introduction 
Let us start by considering a toy example with two assessors and five items. Assessor 1 has stated a set of preferences
$$ \mathcal{B}_{1} = \left\{A_{1} \prec A_{2}, A_{2} \prec A_{5}, A_{4} \prec A_{5} \right\} $$
and assessor 2 has the set of preferences
$$ \mathcal{B}_{2} = \left\{ A_{1} \prec A_{2}, A_{2} \prec A_{3}, A_{3} \prec A_{4} \right\}. $$

### Data Model
Each time an assessor is asked to compare two objects, a measurement is made. Therefore, in order to keep the data *tidy* (@wickham2014), we define a dataframe in which each row corresponds to a pairwise comparison. The columns (variables) are *the assessor*, *the bottom item*, and *the top item*. 

In the code snippet below, we define such a dataframe for the toy example presented above:

```{r, message=FALSE, results='asis'}
pair_comp <- tribble(
  ~assessor, ~bottom_item, ~top_item,
  1, 1, 2,
  1, 2, 5,
  1, 4, 5,
  2, 1, 2,
  2, 2, 3,
  2, 3, 4
)
```

```{r}
knitr::kable(pair_comp, caption = "Dataset `pair_comp`.")
```


#### Transitive Closure

Next, we need to find the transitive closure for the set of pairwise comparisons given by each user. `BayesMallows` comes with a function `generate_transitive_closure` to do just this.


```{r}
pair_comp_tc <- generate_transitive_closure(pair_comp)
```

As we can see, `pair_comp_tc` has an additional row containing the relation $A_{4} \prec A_{5}$ for assessor 1. For assessor 2, $$\text{tc}(\mathcal{B}_{2}) = \mathcal{B}_{2} \cup \left\{ A_{1} \prec A_{3}, A_{1} \prec A_{4}, A_{2} \prec A_{4}\right\},$$ so three new rows have been added.

```{r, results='asis', echo=FALSE}
knitr::kable(pair_comp_tc, caption = "Dataframe `pair_comp_tc`.")
```

The dataframe returned by `generate_transitive_closure` inherits from `tibble`, but has subclass `BayesMallowsTC`. The `compute_mallows` function uses this information to ensure that the object provided has been through the `generate_transitive_closure` function. If it has not, `compute_mallows` will do it for us, but this may lead to additional computing time when running several diagnostic runs and trying out different parameters, since the transitive closure will be recomputed each time.

#### Initial Ranking

We can also generate an initial ranking, consistent with the pairwise comparisons. Again, `compute_mallows` will do it for us, but we may save time by computing it once and for all before we starting running the algorithms.

```{r}
initial_ranking <- generate_initial_ranking(pair_comp_tc)
```

Rather than digging deeper into this toy example, we go on with a real application.


### Beach Preferences
The beach preference dataset is described in Section 6.2 of @vitelli2018, and is available in the dataframe `beach_preferences` in `BayesMallows`. In short, $60$ assessors were each asked to perform a random set of pairwise comparisons between pictures of $15$ beaches. The first few rows are listed below.

```{r, eval=FALSE}
beach_preferences
```


```{r, results='asis', echo=FALSE}
knitr::kable(head(beach_preferences, 6), caption = "Example dataset `beach_preferences`")
```

#### Transitive Closures
We start by generating the transitive closure of the preferences.

```{r}
beach_tc <- generate_transitive_closure(beach_preferences)
```

We can compare the dataframes before and after. We see that the number of rows has been approximately doubled, and that `beach_tc` has subclass `BayesMallowsTC` has it should.

```{r}
str(beach_preferences)
str(beach_tc)
```

#### Initial Ranking
Next, we generate an initial ranking.

```{r}
beach_init_rank <- generate_initial_ranking(beach_tc)
```

We can also take a look at the first 6 rows in it.

```{r, results='asis', echo=FALSE}
knitr::kable(head(beach_init_rank, 6), caption="First 6 rows in `beach_init_rank`.")
```

Let us add column names to the initial ranking. This will make the plots more informative. But be aware that if the names are too long, some plots will be filled with text. We therefore name them B1, B2, ..., B15.

```{r}
colnames(beach_init_rank) <- paste0("B", seq(from = 1, to = ncol(beach_init_rank), by = 1))
```


#### Algorithm Tuning

We can now check the convergence, using the same tools as before.

```{r, error=TRUE}
test_run <- compute_mallows(
  rankings = beach_init_rank, 
  preferences = beach_tc,
  save_augmented_data = TRUE
  )
```

The trace plots for $\alpha$ and $\rho$ show good convergence.

#### Convergence of Rtilde

When using `assess_convergence`, we can set `type = "Rtilde"` and choose `assessors` and `items`. We now illustrate this by going a bit deeper into some assessors. Referring to the mathematical notation in the top of the vignette, `Rtilde` corresponds to the augmented rankings $\tilde{R}_{1}, \dots, \tilde{R}_{N}$.

##### Assessor 1

Let us look at Beach 2 for assessor 1.

```{r, eval=FALSE}
beach_tc %>% 
  filter(assessor == 1, bottom_item == 2 | top_item == 2)
```


```{r, results='asis', echo=FALSE}
beach_tc %>% 
  filter(assessor == 1, bottom_item == 2 | top_item == 2) %>% 
  knitr::kable()
```

It is implied by the preferences of assessor 1 that $\{B_{2} \prec B_{6}\}$ and $\{B_{2} \prec B_{15}\}$.

```{r, fig.width=6}
assess_convergence(test_run, type = "Rtilde", 
                   assessors = 1, items = c(2, 6, 15))
```

This seems correct.

Next, no ordering is implied between beach 2 and 4 for assessor 1.

```{r}
beach_tc %>% 
  filter(assessor == 1, bottom_item %in% c(2, 4), top_item %in% c(2, 4)) %>% 
  nrow()
```

The traces of item 2 and 4 do indeed cross.
```{r, fig.width=6}
assess_convergence(test_run, type = "Rtilde", 
                   assessors = 1, items = c(2, 4))
```


No ordering is implied between beach 5 and beach 8 either:

```{r}
beach_tc %>% 
  filter(assessor == 1, bottom_item %in% c(5, 8), top_item %in% c(5, 8)) %>% 
  nrow()
```

The traces of beaches 5 and 8 do indeed cross.
```{r, fig.width=6}
assess_convergence(test_run, type = "Rtilde", 
                   assessors = 1, items = c(5, 8))
```


##### Assessor 2

We go on with assessor 2. Let us take a look at, say, beach 10. 

```{r, eval=FALSE}
beach_tc %>% 
  filter(assessor == 2, bottom_item == 10 | top_item == 10)
```

```{r, results='asis', echo=FALSE}
beach_tc %>% 
  filter(assessor == 2, bottom_item == 10 | top_item == 10) %>% 
  knitr::kable()
```

Beach 10 is preferred to beach 7, but disfavored to beach 5. The trace plot does indeed show this:

```{r, fig.width=6}
assess_convergence(test_run, type = "Rtilde", 
                   assessors = 2, items = c(5, 7, 10))
```

No ordering is implied between beach 1 and beach 15 for assessor 2.

```{r}
beach_tc %>% 
  filter(assessor == 1, bottom_item %in% c(1, 15), top_item %in% c(1, 15)) %>% 
  nrow()
```

Their traces do indeed cross.
```{r, fig.width=6}
assess_convergence(test_run, type = "Rtilde", 
                   assessors = 2, items = c(1, 15))
```

We delete the test run before going on.

```{r}
rm(test_run)
```


### Posterior Distributions
Based on the convergence diagnostics, and being fairly conservative, we set `burnin = 1000`, and take an additional 5,000 samples. We still save the augmented data, because we are going to call the function `plot_top_k` below.

```{r}
model_fit <- compute_mallows(
  rankings = beach_init_rank, 
  preferences = beach_tc,
  nmc = 6000,
  save_augmented_data = TRUE
  )

model_fit$burnin <- 1000
```

The posterior densities of $\alpha$ and $\rho$ can be studied as shown above.

#### CP Consensus

We can rank the beaches according to the cumulative probability (CP) consensus. This functionality is provided by `compute_cp_consensus`, which returns a dataframe.

```{r, eval=FALSE}
compute_cp_consensus(model_fit)
```


```{r, results='asis', echo=FALSE}
knitr::kable(compute_cp_consensus(model_fit), digits = 2)
```

#### MAP Consensus

The maximum a posterior (MAP) consensus ranking is the a posterior most likely value of $\rho$.

```{r, eval=FALSE}
compute_map_consensus(model_fit)
```


```{r, results='asis', echo=FALSE}
knitr::kable(compute_map_consensus(model_fit), digits = 2)
```

#### Posterior Intervals

We can compute posterior intervals for several parameters. Here we do it for $\rho$.

```{r, eval=FALSE}
compute_posterior_intervals(model_fit, parameter = "rho")
```


```{r, results='asis', echo=FALSE}
knitr::kable(compute_posterior_intervals(model_fit, parameter = "rho"))
```


#### Posterior Probability of Being Ranked Top-$k$

We can also find the posterior probability for each beach of being ranked top-$k$, both in $\rho$ and among the assessors.

We can do a top-$k$ plot with `plot_top_k`. By default, `k = 3`. It may be necessary to do some experimentation with the `rel_widths` argument to get a good looking plot.

```{r, fig.width=6}
plot_top_k(model_fit, rel_widths = c(1, 8))
```


## Clustering of Assessors

In many situations, it is interesting to divide the assessors into clusters, in which each the assessors in each cluster have similar preferences. In @vitelli2018, Section 4.3, it is shown how the Bayesian Mallows model can be extended to do exactly this, with a mixture approach. `BayesMallows` supports this through the optional argument `n_clusters` to `compute_mallows`.

### Introduction

To illustrate how to perform clustering, let us create some clusters in the `potato_visual` dataset. This dataset has 12 assessors. We leave the first 6 assessors as is, but for the last 6, we revert the rankings.

```{r}
potato_manipulated <- potato_visual
potato_manipulated[7:12, ] <- 21 - potato_manipulated[7:12, ]
```

```{r, echo=FALSE, results='asis'}
knitr::kable(potato_manipulated, caption = "Dataset `potato_manipulated`.")
```

Let us try first without clustering.
```{r}
model_fit <- compute_mallows(rankings = potato_manipulated)
```

Looking at the convergence of $\alpha$, we see that this model does not settle on a consensus ranking.
```{r, fig.width=6}
assess_convergence(model_fit)
```

Let us instead introduce clustering:

```{r}
model_fit <- compute_mallows(
  rankings = potato_manipulated, 
  n_clusters = 2
  )
```

#### Algorithm Tuning

##### Convergence of $\alpha$
We can assess convergence in the usual way. Let us start with `alpha`. The `assess_convergence` method now shows one trace per cluster.

```{r, fig.width=6}
assess_convergence(model_fit)
```



##### Convergence of $\rho$

We plot the potato that is most often ranked heaviest (P8), and the potato that is most often ranked lightest (P12). 

```{r, fig.width=6}
assess_convergence(model_fit, type = "rho", items = c(8, 12))
```

##### Convergence of Cluster Probabilities

We also see that the probability of each cluster, $\tau_{1}$ and $\tau_{2}$, fluctuate around 0.5, which is just as expected, since we reverted half of the rankings.

```{r, fig.width=6}
assess_convergence(model_fit, type = "cluster_probs")
```

We now go on to show clustering in a real data example.

### Sushi Data
The `BayesMallows` package comes with a set of sushi preference data, in which 5000 assessors each have ranked a set of 10 types of sushi (@kamishima2003). Here are the first few rows of the dataset.

```{r, eval=FALSE}
sushi_rankings
```


```{r, echo=FALSE, results='asis'}
knitr::kable(head(sushi_rankings), caption = "First 6 rows of example dataset `sushi_rankings`.")
```

With clustering, we can see if there are subsets of assessors with similar preferences. We set `nmc = 1000` here, to speed up the vignette building. The argument `include_wcd` specifies whether to compute within-cluster distance during MCMC. When `n_cluster > 1` it defaults to `TRUE`, otherwise to `FALSE`. Hence, in order to get the within-cluster distance for the one-cluster case, we set `include_wcd = TRUE` when calling `compute_mallows`:

```{r}
model_fit1 <- compute_mallows(sushi_rankings, nmc = 1000, include_wcd = TRUE)
model_fit2 <- compute_mallows(sushi_rankings, n_clusters = 2, nmc = 1000)
```

#### Algorithm Tuning

It is useful to look at the trace plots of $\alpha_{1}, \dots, \alpha_{C}$.

```{r}
assess_convergence(model_fit2)
```

We can also look at the trace plot of the cluster probabilities, $\tau_{1}$ and $\tau_{2}$:

```{r}
assess_convergence(model_fit2, type = "cluster_probs")
```


It seems like $\alpha$ is mixing rapidly. Let us set `burnin = 400`, and compute the CP consensus for the case with two clusters.

```{r}
model_fit1$burnin <- 400
model_fit2$burnin <- 400
```


#### Posterior Distributions

##### CP Consensus


We can find the CP consensus for each of the two clusters.
```{r}
cp_consensus_sushi <- compute_cp_consensus(model_fit2)
```

We can now look at each cluster:

```{r, eval=FALSE}
filter(cp_consensus_sushi, cluster == "Cluster 1")
```


```{r, echo=FALSE, results='asis'}
knitr::kable(filter(cp_consensus_sushi, cluster == "Cluster 1"), digits = 2)
```

```{r, eval=FALSE}
filter(cp_consensus_sushi, cluster == "Cluster 2")
```


```{r, echo=FALSE, results='asis'}
knitr::kable(filter(cp_consensus_sushi, cluster == "Cluster 2"), digits = 2)
```

##### Determining the Number of Clusters

We can also compute an elbow plot, using `plot_elbow`. Before doing that, we should look at its arguments:
```{r}
args(plot_elbow)
```

`plot_elbow` requires the model fits for different number of clusters to be provided as the first arguments, either comma separated, or as a list. The other argument is `burnin`, which must be named. If each model provided has its `burnin` element set, then this is taken as the default value of `burnin`.

In order to systematically investigate how many clusters to include, we can use the function `compute_mallows_mixtures`, which takes a vector that specifies the number of clusters, and calls `compute_mallows` once for each number. 

We only need the within-cluster distances to compute the elbow plot. Thus, we can basically "thin out" all the other parameters, since we do not need them. This reduce the amount of memory used.

```{r, message=FALSE}
n_clusters <- seq(from = 1, to = 10)
nmc <- 2000
models <- compute_mallows_mixtures(n_clusters = n_clusters, 
                                   rankings = sushi_rankings,
                                   nmc = nmc, 
                                   cluster_assignment_thinning = nmc - 1,
                                   rho_thinning = nmc - 1,
                                   aug_thinning = nmc - 1
                                   )
```

Even though the result of `compute_mallows_mixtures` is a list of fitted models, we can specify `burnin` as an element in this case as well, and it is used by `plot_elbow`.

We can now provide the `models` list to `plot_elbow`. 

```{r}
plot_elbow(models, burnin = 1000)
```

Let us choose 5 clusters. We then compute this model, now without the extreme thinning.

```{r}
model <- compute_mallows(rankings = sushi_rankings, nmc = nmc, n_clusters = 5)
```


```{r}
plot(model, burnin = 1000, type = "cluster_assignment")
```


We can also the function `assign_cluster` to get the a posteriori cluster assignment for each assessor.
```{r}
cluster_assignment <- assign_cluster(model, burnin = 1000, soft = FALSE)
```


```{r, echo=FALSE, results='asis'}
knitr::kable(cluster_assignment, caption = "The first few rows of `cluster_assignment`.")
```

# References
